--[[
	Modernized DevProduct Handler (2025 Standards)
	Handles Robux purchases for tycoon items and currency
--]]

local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local DataStoreService = game:GetService("DataStoreService")
local Settings = require(script.Parent.Settings)

-- Get reference tycoon for dev products
local tycoonFolder = script.Parent:WaitForChild("Tycoons")
local referenceTycoon = tycoonFolder:GetChildren()[1]

-- Move to ServerScriptService for security
script.Parent = game.ServerScriptService

-- Build dev products table (maps ProductId -> Button instance)
local DevProducts = {}
local buttonsFolder = referenceTycoon:WaitForChild("Buttons")

for _, button in ipairs(buttonsFolder:GetChildren()) do
	local devProduct = button:FindFirstChild("DevProduct")
	if devProduct and devProduct.Value > 0 then
		DevProducts[devProduct.Value] = button
		print("Registered DevProduct:", devProduct.Value, "for button:", button.Name)
	end
end

-- Currency developer products mapping (ProductId -> amount)
-- TODO: Replace IDs/amounts with your actual product IDs
local CurrencyProducts = {
	[3366419712] = 1000,
	[3366420012] = 5000,
	[3366420478] = 10000,
	[3366420800] = 25000,
}

-- Idempotency store to avoid duplicate grants
local purchaseHistoryStore = DataStoreService:GetDataStore("PurchaseHistory")

-- Modern ProcessReceipt implementation
local function processReceipt(receiptInfo)
	-- Find the player
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	local moneyFolder = ServerStorage:WaitForChild("PlayerMoney")
	local playerMoney = moneyFolder:FindFirstChild(player.Name)
	if not playerMoney then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- Idempotency key per unique purchase
	local purchaseKey = string.format("player_%d_purchase_%s", receiptInfo.PlayerId, tostring(receiptInfo.PurchaseId))
	local okGet, alreadyProcessed = pcall(function()
		return purchaseHistoryStore:GetAsync(purchaseKey)
	end)
	if not okGet then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end
	if alreadyProcessed then
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	-- 1) Currency products: grant cash directly
	local currencyAmount = CurrencyProducts[receiptInfo.ProductId]
	if currencyAmount then
		playerMoney.Value = playerMoney.Value + currencyAmount
		local okSet, errSet = pcall(function()
			purchaseHistoryStore:SetAsync(purchaseKey, true)
		end)
		if not okSet then
			return Enum.ProductPurchaseDecision.NotProcessedYet
		end
		print(string.format("Currency product %d (+%d) granted to %s", receiptInfo.ProductId, currencyAmount, player.Name))
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	-- 2) Tycoon button products: forward to BuyObject for server-authoritative spawn
	local buttonInfo = DevProducts[receiptInfo.ProductId]
	if not buttonInfo then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	local ownsTycoon = playerMoney:FindFirstChild("OwnsTycoon")
	if not ownsTycoon or not ownsTycoon.Value then
		return Enum.ProductPurchaseDecision.NotProcessedYet
	end

	-- Create purchase instruction for the tycoon
	local purchaseData = Instance.new("Model")
	purchaseData.Name = "DevProductPurchase_" .. receiptInfo.ProductId

	local cost = Instance.new("NumberValue")
	cost.Name = "Cost"
	cost.Value = 0 -- Paid with Robux
	cost.Parent = purchaseData

	local buttonRef = Instance.new("ObjectValue")
	buttonRef.Name = "Button"
	buttonRef.Value = buttonInfo
	buttonRef.Parent = purchaseData

	local statsRef = Instance.new("ObjectValue")
	statsRef.Name = "Stats"
	statsRef.Value = playerMoney
	statsRef.Parent = purchaseData

	-- Send to tycoon's BuyObject folder
	local buyObject = ownsTycoon.Value:FindFirstChild("BuyObject")
	if buyObject then
		purchaseData.Parent = buyObject
		local okSet2, errSet2 = pcall(function()
			purchaseHistoryStore:SetAsync(purchaseKey, true)
		end)
		if not okSet2 then
			return Enum.ProductPurchaseDecision.NotProcessedYet
		end
		print(string.format("DevProduct %d forwarded to tycoon for %s", receiptInfo.ProductId, player.Name))
		return Enum.ProductPurchaseDecision.PurchaseGranted
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- Set the ProcessReceipt callback
MarketplaceService.ProcessReceipt = processReceipt

-- Add error handling for failed purchases
MarketplaceService.PromptProductPurchaseFinished:Connect(function(userId, productId, wasPurchased)
	if not wasPurchased then
		local player = Players:GetPlayerByUserId(userId)
		if player then
			print(string.format("Product purchase cancelled: Player %s, Product %d", player.Name, productId))
		end
	end
end)

print("DevProduct Handler initialized with", #DevProducts, "products and", tostring(#(function(t)local c=0 for _ in pairs(CurrencyProducts) do c=c+1 end return {c} end)(CurrencyProducts)[1]), "currency products")